/**
 * JSON 출력에서 TypeScript 타입 자동 생성
 *
 * 사용법: bun run scripts/generate-types.ts
 *
 * 기존 코드 수정 없이 실제 JSON 출력에서 타입을 생성합니다.
 */
import { InputData, jsonInputForTargetLanguage, quicktype } from 'quicktype-core';
import { toJson } from '../dist/index.js';
import { readFileSync, writeFileSync, readdirSync } from 'fs';
import { join } from 'path';

/**
 * 타입 정의 후처리
 * - quicktype이 생성한 리터럴 유니온을 적절한 타입으로 교체
 * - 데이터 값이 타입으로 변환된 것을 수정
 */
function postProcessTypes(content: string): string {
  let result = content;

  // 1. 버전, 이름 등 데이터가 리터럴로 변환된 타입을 string으로 교체
  const literalToString = [
    // FileHeader 관련
    /export type Signature = [^;]+;/g,
    /export type VersionEnum = [^;]+;/g,
    /export type DocumentFlag = [^;]+;/g,

    // SummaryInformation 관련 - 데이터 값들
    /export type Comments = [^;]+;/g,
    /export type Keywords = [^;]+;/g,
    /export type LastSavedBy = [^;]+;/g,
    /export type RevisionNumber = [^;]+;/g,
    /export type Subject = [^;]+;/g,

    // 폰트 관련
    /export type AlternativeFontName = [^;]+;/g,
    /export type AlternativeFontType = [^;]+;/g,

    // 포맷 관련
    /export type Format = [^;]+;/g,
    /export type LevelFormatString = [^;]+;/g,
    /export type ExtendedLevelFormatString = [^;]+;/g,
    /export type Prefix = [^;]+;/g,
  ];

  for (const pattern of literalToString) {
    result = result.replace(pattern, (match) => {
      const typeName = match.match(/export type (\w+)/)?.[1];
      return `export type ${typeName} = string;`;
    });
  }

  // 2. signature 필드를 string으로 교체
  result = result.replace(
    /signature:\s+Signature;/g,
    'signature: string;'
  );

  // 3. version 필드의 VersionEnum을 string으로
  result = result.replace(
    /version:\s+VersionEnum;/g,
    'version: string;'
  );

  // 4. Purple/Fluffy/Tentacled/Sticky 등 자동 생성 이름에 대한 주석 추가
  const autoGeneratedNames = [
    'PurpleRecord',
    'FluffyRecord',
    'TentacledRecord',
    'StickyRecord',
    'IndigoRecord',
    'PurpleChild',
    'FluffyChild',
    'TentacledChild',
    'StickyChild',
    'PurpleParagraph',
    'FluffyParagraph',
    'CellParagraph',
    'RecordParagraph',
  ];

  // 5. enum으로 사용해야 할 것들은 그대로 유지 (유의미한 유니온)
  // RecordType, Kind, Name 등은 실제 enum 역할을 하므로 유지

  return result;
}

async function generateTypes() {
  console.log('=== Generating TypeScript types from JSON samples ===\n');

  // 샘플 HWP 파일들에서 JSON 수집
  const fixturesPath = join(__dirname, '../../../crates/hwp-core/tests/fixtures');
  const jsonSamples: string[] = [];

  const files = readdirSync(fixturesPath).filter(f => f.endsWith('.hwp'));
  console.log(`Found ${files.length} HWP files\n`);

  for (const file of files) {
    try {
      const hwpData = readFileSync(join(fixturesPath, file));
      const json = toJson(hwpData);
      jsonSamples.push(json);
      console.log(`✓ ${file}`);
    } catch (e: any) {
      console.log(`✗ ${file} - ${e.message.slice(0, 50)}`);
    }
  }

  console.log(`\nCollected ${jsonSamples.length} JSON samples\n`);

  if (jsonSamples.length === 0) {
    console.error('No valid JSON samples found');
    process.exit(1);
  }

  // quicktype으로 TypeScript 타입 생성
  const jsonInput = jsonInputForTargetLanguage('typescript');

  await jsonInput.addSource({
    name: 'HwpDocument',
    samples: jsonSamples,
  });

  const inputData = new InputData();
  inputData.addInput(jsonInput);

  const result = await quicktype({
    inputData,
    lang: 'typescript',
    rendererOptions: {
      'just-types': 'true',
      'prefer-unions': 'true',
    },
  });

  // 후처리 적용
  const rawContent = result.lines.join('\n');
  const processedContent = postProcessTypes(rawContent);

  // 파일 저장
  const outputPath = join(__dirname, '../types/hwp-document.d.ts');
  const header = `/**
 * HWP Document Type Definitions
 *
 * AUTO-GENERATED from JSON output samples
 * Re-run \`bun run generate:types\` to update after Rust code changes.
 *
 * Generated: ${new Date().toISOString()}
 * Samples: ${jsonSamples.length} HWP files
 *
 * Note: Some type names (Purple*, Fluffy*, etc.) are auto-generated by quicktype
 * to avoid naming conflicts. These represent nested record/child structures.
 *
 * Usage:
 *   import type { HwpDocument, Table, Section } from '@ohah/hwpjs/types/hwp-document';
 *   const doc: HwpDocument = JSON.parse(toJson(hwpBuffer));
 */

`;

  writeFileSync(outputPath, header + processedContent);
  console.log(`\n✓ Generated: ${outputPath}`);
  console.log(`  Size: ${processedContent.split('\n').length} lines`);
  console.log(`  Post-processing applied`);
}

generateTypes().catch(console.error);
